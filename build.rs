// Build script for precompiled schema generation
// This script will generate embedded schema constants for faster startup

#[cfg(feature = "precompiled-schemas")]
use std::env;
#[cfg(feature = "precompiled-schemas")]
use std::fs::{self, File};
#[cfg(feature = "precompiled-schemas")]
use std::io::Write;
#[cfg(feature = "precompiled-schemas")]
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // Only generate precompiled schemas if the feature is enabled
    #[cfg(feature = "precompiled-schemas")]
    {
        generate_precompiled_schemas().unwrap_or_else(|e| {
            eprintln!("Warning: Failed to generate precompiled schemas: {e}");
            eprintln!("Continuing without precompiled schemas...");
        });
    }

    // Set up conditional compilation
    if cfg!(feature = "embedded-providers") {
        println!("cargo:rustc-cfg=embedded_providers");
    }

    if cfg!(feature = "dynamic-caching") {
        println!("cargo:rustc-cfg=dynamic_caching");
    }
}

#[cfg(feature = "precompiled-schemas")]
fn generate_precompiled_schemas() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = env::var("OUT_DIR")?;
    let dest_path = Path::new(&out_dir).join("precompiled_schemas.rs");

    let mut file = File::create(&dest_path)?;

    writeln!(file, "// Auto-generated precompiled schemas")?;
    writeln!(file, "// This file is generated by build.rs")?;
    writeln!(file)?;
    writeln!(file, "#[cfg(feature = \"embedded-providers\")]")?;
    writeln!(file, "pub mod embedded {{")?;
    writeln!(file, "    use std::collections::HashMap;")?;
    writeln!(file)?;

    // Create precompiled_schemas directory if it doesn't exist
    let schemas_dir = Path::new("precompiled_schemas");
    if !schemas_dir.exists() {
        fs::create_dir_all(schemas_dir)?;

        // Create placeholder schema files for each FHIR version
        let versions = ["r4", "r4b", "r5", "r6"];
        for version in &versions {
            let schema_file = schemas_dir.join(format!("{version}_schemas.bin"));
            if !schema_file.exists() {
                // Create empty placeholder file
                File::create(&schema_file)?;
                println!("cargo:warning=Created placeholder schema file: {schema_file:?}");
            }
        }
    }

    // Include binary schema data for each FHIR version
    let versions = ["r4", "r4b", "r5", "r6"];
    for version in &versions {
        let schema_file = format!("precompiled_schemas/{version}_schemas.bin");

        writeln!(
            file,
            "    /// Precompiled schemas for FHIR {}",
            version.to_uppercase()
        )?;
        writeln!(
            file,
            "    pub static {}_SCHEMAS: &[u8] = include_bytes!(\"../../{}\");",
            version.to_uppercase(),
            schema_file
        )?;
        writeln!(file)?;
    }

    writeln!(file, "    /// Get precompiled schemas for a FHIR version")?;
    writeln!(
        file,
        "    pub fn get_schemas(version: &str) -> Option<&'static [u8]> {{"
    )?;
    writeln!(file, "        match version {{")?;
    for version in &versions {
        writeln!(
            file,
            "            \"{}\" => Some({}_SCHEMAS),",
            version,
            version.to_uppercase()
        )?;
    }
    writeln!(file, "            _ => None,")?;
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    writeln!(file)?;

    writeln!(
        file,
        "    /// Get all available FHIR versions with precompiled schemas"
    )?;
    writeln!(
        file,
        "    pub fn available_versions() -> &'static [&'static str] {{"
    )?;
    writeln!(file, "        &{versions:?}")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    println!("cargo:warning=Generated precompiled schemas module");
    Ok(())
}

#[cfg(not(feature = "precompiled-schemas"))]
fn generate_precompiled_schemas() -> Result<(), Box<dyn std::error::Error>> {
    // Do nothing if feature is not enabled
    Ok(())
}
