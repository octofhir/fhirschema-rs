// ModelProvider Trait Implementation Demo
//
// This example demonstrates that FhirSchemaModelProvider properly implements
// the ModelProvider trait from fhir-model-rs, enabling full integration
// with the OctoFHIR ecosystem.

use octofhir_fhir_model::type_system::PolymorphicContext;
use octofhir_fhirschema::prelude::*;

#[tokio::main]
async fn main() -> Result<()> {
    println!("üöÄ ModelProvider Trait Implementation Demo");

    // ========================================================================
    // Demo 1: Create Provider - Simple API Hidden Behind Trait
    // ========================================================================

    println!("\nüìã Demo 1: ModelProvider Creation");

    // Create the provider with simple API
    let provider = FhirSchemaModelProvider::r4().await?;

    // Use as ModelProvider trait - this proves full trait implementation
    let model_provider: &dyn ModelProvider = &provider;

    println!("  ‚úÖ FhirSchemaModelProvider created and cast to ModelProvider trait");
    println!("  üìå FHIR Version: {}", model_provider.get_fhir_version());

    // ========================================================================
    // Demo 2: Core Type Operations via Trait
    // ========================================================================

    println!("\nüèóÔ∏è  Demo 2: Core Type Operations via ModelProvider Trait");

    // Test type hierarchy
    match model_provider.get_type_hierarchy("Patient").await {
        Ok(Some(hierarchy)) => {
            println!("  ‚úÖ Type hierarchy retrieved via trait:");
            println!("    Type: {}", hierarchy.type_name);
            println!("    Parent: {:?}", hierarchy.direct_parent);
            println!("    Child Types: {} found", hierarchy.direct_children.len());
        }
        Ok(None) => println!("  ‚ÑπÔ∏è  No hierarchy found for Patient"),
        Err(e) => println!("  ‚ö†Ô∏è  Error getting hierarchy: {e}"),
    }

    // Test type compatibility
    match model_provider
        .is_type_compatible("Patient", "Resource")
        .await
    {
        Ok(compatible) => println!("  ‚úÖ Type compatibility Patient->Resource: {compatible}"),
        Err(e) => println!("  ‚ö†Ô∏è  Compatibility check failed: {e}"),
    }

    // Test common supertype
    let types = vec!["Patient".to_string(), "Practitioner".to_string()];
    match model_provider.get_common_supertype(&types).await {
        Ok(Some(supertype)) => println!("  ‚úÖ Common supertype: {supertype}"),
        Ok(None) => println!("  ‚ÑπÔ∏è  No common supertype found"),
        Err(e) => println!("  ‚ö†Ô∏è  Supertype resolution failed: {e}"),
    }

    // ========================================================================
    // Demo 3: Navigation Operations via Trait
    // ========================================================================

    println!("\nüß≠ Demo 3: Navigation Operations via ModelProvider Trait");

    let navigation_tests = vec![
        ("Patient", "name"),
        ("Patient", "name.family"),
        ("Observation", "value[x]"),
    ];

    for (base_type, path) in navigation_tests {
        println!("  Testing navigation: {base_type}.{path}");

        // Navigate typed path via trait
        match model_provider.navigate_typed_path(base_type, path).await {
            Ok(result) => {
                println!("    ‚úÖ Navigation successful: {}", result.is_success);
                let type_info = &result.result_type;
                println!(
                    "    üìç Result Type: TypeInfo ({})",
                    type_info.namespace().unwrap_or("Unknown")
                );
            }
            Err(e) => println!("    ‚ùå Navigation failed: {e}"),
        }

        // Validate navigation safety via trait
        match model_provider
            .validate_navigation_safety(base_type, path)
            .await
        {
            Ok(validation) => {
                println!("    üõ°Ô∏è  Safety validation: {}", validation.is_valid);
            }
            Err(e) => println!("    ‚ö†Ô∏è  Safety validation failed: {e}"),
        }

        // Get navigation metadata via trait
        match model_provider
            .get_navigation_metadata(base_type, path)
            .await
        {
            Ok(metadata) => {
                println!(
                    "    üìä Navigation metadata: path={}, target_type={}",
                    metadata.path, metadata.target_type
                );
            }
            Err(e) => println!("    ‚ö†Ô∏è  Metadata retrieval failed: {e}"),
        }
    }

    // ========================================================================
    // Demo 4: Choice Type Operations via Trait
    // ========================================================================

    println!("\nüéØ Demo 4: Choice Type Operations via ModelProvider Trait");

    // Test choice type resolution via trait
    let polymorphic_context = PolymorphicContext {
        current_path: "Observation.value[x]".to_string(),
        base_type: "Observation".to_string(),
        available_types: vec!["string".to_string(), "Quantity".to_string()],
        constraints: Vec::new(),
        inference_hints: Vec::new(),
        resolution_strategy: octofhir_fhir_model::type_system::ResolutionStrategy::FirstMatch,
        metadata: std::collections::HashMap::new(),
    };

    match model_provider
        .resolve_choice_type("value[x]", &polymorphic_context)
        .await
    {
        Ok(resolution) => {
            println!("  ‚úÖ Choice type resolution:");
            println!("    Resolved Type: {}", resolution.resolved_type);
            println!("    Confidence: {:.2}", resolution.confidence_score);
            println!(
                "    Alternatives: {} found",
                resolution.alternative_types.len()
            );
        }
        Err(e) => println!("  ‚ö†Ô∏è  Choice type resolution failed: {e}"),
    }

    // Test choice expansions via trait
    match model_provider.get_choice_expansions("value[x]").await {
        Ok(expansions) => {
            println!("  ‚úÖ Choice expansions: {} found", expansions.len());
            for expansion in expansions.iter().take(3) {
                println!("    - Choice Property: {}", expansion.choice_property);
                println!(
                    "      Forward mappings: {} entries",
                    expansion.forward_mappings.len()
                );
                println!(
                    "      Reverse mappings: {} entries",
                    expansion.reverse_mappings.len()
                );
            }
        }
        Err(e) => println!("  ‚ö†Ô∏è  Choice expansions failed: {e}"),
    }

    // Test choice type inference via trait
    match model_provider.infer_choice_type(&polymorphic_context).await {
        Ok(inference) => {
            println!("  ‚úÖ Type inference:");
            println!(
                "    Confidence threshold: {:.2}",
                inference.confidence_threshold
            );
            println!(
                "    Inference rules: {} found",
                inference.inference_rules.len()
            );
        }
        Err(e) => println!("  ‚ö†Ô∏è  Type inference failed: {e}"),
    }

    // ========================================================================
    // Demo 5: FHIRPath Functions via Trait
    // ========================================================================

    println!("\nüîç Demo 5: FHIRPath Functions via ModelProvider Trait");

    // Test profile conformance via trait
    let profile_url = "http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient";
    match model_provider.conforms_to_profile(profile_url).await {
        Ok(conformance) => {
            println!("  ‚úÖ Profile conformance check:");
            println!("    Profile: {}", conformance.profile_url);
            println!("    Valid: {}", conformance.is_valid);
            println!("    Resource Type: {:?}", conformance.resource_type);
        }
        Err(e) => println!("  ‚ö†Ô∏è  Conformance check failed: {e}"),
    }

    // Test expression type analysis via trait
    let test_expression = "Patient.name.family";
    match model_provider
        .analyze_expression_types(test_expression)
        .await
    {
        Ok(analysis) => {
            println!("  ‚úÖ Expression analysis:");
            println!("    Expression: {}", analysis.expression);
            println!("    Analysis complete");
        }
        Err(e) => println!("  ‚ö†Ô∏è  Expression analysis failed: {e}"),
    }

    // Test FHIRPath expression validation via trait
    match model_provider
        .validate_fhirpath_expression(test_expression, "Patient")
        .await
    {
        Ok(validation) => {
            println!("  ‚úÖ FHIRPath validation: {}", validation.is_valid);
        }
        Err(e) => println!("  ‚ö†Ô∏è  FHIRPath validation failed: {e}"),
    }

    // ========================================================================
    // Demo 6: Advanced Operations via Trait
    // ========================================================================

    println!("\nüîß Demo 6: Advanced Operations via ModelProvider Trait");

    // Test collection semantics via trait
    match model_provider.get_collection_semantics("Patient").await {
        Ok(semantics) => {
            println!("  ‚úÖ Collection semantics retrieved for Patient");
            println!("    Default semantics applied");
        }
        Err(e) => println!("  ‚ö†Ô∏è  Collection semantics failed: {e}"),
    }

    // Test optimization hints via trait
    match model_provider.get_optimization_hints("Patient.name").await {
        Ok(hints) => {
            println!("  ‚úÖ Optimization hints: {} found", hints.len());
        }
        Err(e) => println!("  ‚ö†Ô∏è  Optimization hints failed: {e}"),
    }

    // ========================================================================
    // Demo 7: Core Information Methods via Trait
    // ========================================================================

    println!("\nüìö Demo 7: Core Information Methods via ModelProvider Trait");

    // Test type reflection via trait
    match model_provider.get_type_reflection("Patient").await {
        Ok(Some(reflection)) => {
            println!("  ‚úÖ Type reflection:");
            println!("    Namespace: {:?}", reflection.namespace());
            println!("    Reflection info available");
        }
        Ok(None) => println!("  ‚ÑπÔ∏è  No reflection info for Patient"),
        Err(e) => println!("  ‚ö†Ô∏è  Type reflection failed: {e}"),
    }

    // Test constraints via trait
    match model_provider.get_constraints("Patient").await {
        Ok(constraints) => {
            println!("  ‚úÖ Constraints: {} found", constraints.len());
            for constraint in constraints.iter().take(2) {
                println!(
                    "    - {} ({}): {}",
                    constraint.key, constraint.severity, constraint.human
                );
            }
        }
        Err(e) => println!("  ‚ö†Ô∏è  Constraints retrieval failed: {e}"),
    }

    // Test supported resource types via trait
    match model_provider.get_supported_resource_types().await {
        Ok(types) => {
            println!("  ‚úÖ Supported resource types: {} found", types.len());
            println!("    Types: {}", types.join(", "));
        }
        Err(e) => println!("  ‚ö†Ô∏è  Resource types retrieval failed: {e}"),
    }

    // Test cache clearing via trait
    match model_provider.clear_caches().await {
        Ok(_) => println!("  ‚úÖ Caches cleared successfully via trait"),
        Err(e) => println!("  ‚ö†Ô∏è  Cache clearing failed: {e}"),
    }

    // ========================================================================
    // Summary
    // ========================================================================

    println!("\n‚úÖ ModelProvider Trait Implementation Demo Completed!");
    println!("\nüìã Key Achievements:");
    println!("  üéØ Full ModelProvider Trait: All methods implemented");
    println!("  üèóÔ∏è  Core Type Operations: Hierarchy, compatibility, supertypes");
    println!("  üß≠ Navigation Operations: Path navigation, safety validation, metadata");
    println!("  üéØ Choice Type Operations: Resolution, expansions, inference");
    println!("  üîç FHIRPath Functions: Conformance, analysis, validation");
    println!("  üîß Advanced Operations: Collection semantics, optimization hints");
    println!("  üìö Information Methods: Type reflection, constraints, resource types");

    println!("\nüöÄ FhirSchemaModelProvider is now fully compatible with the");
    println!("   OctoFHIR ecosystem through the ModelProvider trait!");
    println!("   It can be used anywhere a ModelProvider is expected.");

    Ok(())
}
